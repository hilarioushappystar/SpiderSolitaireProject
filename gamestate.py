###########################################
#  This is the Gamestate class
#  This class maintains the "current state of play" during a game
#  It also has functionality such as determining all legal moves or
#  evaluating how good a position is (e.g. counting in-suit builds etc).
###########################################


from card import Card
import random
import numpy as np

#random.seed(123456)



class Gamestate():
 
    # generate a random starting position
    # the first four columns have one more card than the others
    # (as per the Microsoft Windows version)
    def init_random(self):         
        templist = []
        for number in range(52):
            templist.append(Card.id2card(number))
            templist.append(Card.id2card(number))
        random.shuffle(templist)
        self.columns = [ [],[],[],[],[],[],[],[],[],[] ]
        self.stock = [ [],[],[],[],[],[],[],[],[],[] ]    
        for i in range(10):
            for j in range(11):
                if( i < 4 or j > 0):
                    mycard = templist.pop()
                    if( j < 6):
                        if( j<5):
                            mycard.isvisible=False
                        self.columns[i].append(mycard)
                    else:
                        self.stock[i].append(mycard)

    # generate starting position corresponding to filename
    # assume filename has same format as that generated by init_random
    def init_filename(self,filename):
        self.columns = [ [],[],[],[],[],[],[],[],[],[] ]
        self.stock = [ [],[],[],[],[],[],[],[],[],[] ]
        linecounter = 0
        with open(filename,mode='r') as f:
            for line in f:
                pieces = line.split()
                for counter in range(len(pieces)):
                    c1 = Card(pieces[counter])
                        
                    if( linecounter < 10):
                        self.columns[linecounter].append(c1)
                    else:
                        self.stock[linecounter-10].append(c1)
                linecounter += 1

    # make sure every card appears twice
    def sanity_check(self):
        cardcounts = np.zeros(52)
        for i in range(10):
            for c in self.columns[i]:
                id = c.card2id()
                cardcounts[id] += 1
            for c in self.stock[i]:
                id = c.card2id()
                cardcounts[id] += 1
        flag = False
        for dweet in cardcounts:
            if ( dweet != 2):
                flag = True
        if(flag):
            tempstr = "WARNING: NOT EVERY CARD APPEARS TWICE!!!\n"
            tempstr += str(cardcounts[0:13]) + '\n' + str(cardcounts[13:26]) +  '\n' + str( cardcounts[26:39]) + '\n' + str(cardcounts[39:52])
            #print("WARNING: NOT EVERY CARD APPEARS TWICE!!!")
            #print(str(cardcounts[0:13]) + '\n' + str(cardcounts[13:26]) +  '\n' + str( cardcounts[26:39]) + '\n' + str(cardcounts[39:52]))
            #return "WARNING: NOT EVERY CARD APPEARS TWICE!!!"
            return tempstr
        else:
            #print("CORRECT DISTRIBUTION")
            return "CORRECT DISTRIBUTION"
    # find the maximum cards in a column that can move to an empty column (assuming the latter exists)
    def runlength(self,column_id):
        column = self.columns[column_id]
        if( len(column) == 0):
            return 0
        index = len(column) - 1
        while True:
            if( index == 0):
                return len(column)
            card = column[index]
            card2 = column[index-1]
            if( card.issamesuit(card2) and card.isnextrank(card2) and card2.isvisible):
                index = index -1
            else:
                return len(column) - index
    
    # determine if a move is legal. Returns an integer instead of boolean
    # return (0=illegal), (1=lose suited build), (2=neutral), (3=gain suited build)
    def islegal(self,fromcolumn_id,tocolumn_id):
        fromcolumn = self.columns[fromcolumn_id]
        tocolumn = self.columns[tocolumn_id]
        
        if( len(fromcolumn) == 0):  # can't move zero cards anywhere!
            return 0
        if( fromcolumn[len(fromcolumn)-1].isvisible == False): # can't move a card that's not exposed!
            return 0
        if( len(tocolumn) == 0):    # anything that's non-empty can move to empty column
            if( self.runlength(fromcolumn_id) == len(fromcolumn)):
                return 0  # cannot make a move that is equivalent to passing
            return 2
        from_topcard = fromcolumn[len(fromcolumn) - 1]
        to_topcard = tocolumn[len(tocolumn) - 1]
        if( from_topcard.getrank() >= to_topcard.getrank()):
            return 0
        
        # we know from's topcard is less than to's topcard
        mydelta = to_topcard.getrank() - from_topcard.getrank()
        if( len(fromcolumn) < mydelta): # not enough cards
            return 0  
        if( fromcolumn[len(fromcolumn)-mydelta].isvisible == False ):  # not enough exposed cards
            return 0
        for zebo in range(mydelta-1):   # now test if the ranks are correct
            card1 = fromcolumn[len(fromcolumn)-1-zebo]; card2 = fromcolumn[len(fromcolumn)-2-zebo]
            if( card1.isnextrank(card2) == False):
                return -2
        # now count the number of in-suit breaks in the run
        numbreaks = 0
        for zebo in range(mydelta-1):
            card1 = fromcolumn[len(fromcolumn)-1-zebo]; card2 = fromcolumn[len(fromcolumn)-2-zebo]
            if( card1.issamesuit(card2) == False):
                numbreaks += 1
        # now count the number of spaces available, excluding the "to" column
        numspaces = 0
        for zebo in range(10):
            if( zebo != fromcolumn_id and len(self.columns[zebo]) == 0):
                numspaces += 1
        if( 2 ** numspaces <= numbreaks):
            return 0

        # now the move is legal, we just gotta work out if we are losing or gaining suited build
        from_middlecard = fromcolumn[len(fromcolumn)-mydelta]
        from_othercard = fromcolumn[len(fromcolumn)-mydelta - 1]
        magicnumber = 2
        if( from_middlecard.issamesuit(to_topcard)):
            magicnumber += 1
        if( from_middlecard.issamesuit(from_othercard) and from_middlecard.isnextrank(from_othercard)):
            if( from_othercard.isvisible):
                magicnumber -= 1
        return magicnumber


    # this is only included for convenience
    def islegal2(self,fromcolumn_id,tocolumn_id,threshold):    
        return (self.islegal(fromcolumn_id,tocolumn_id) >= threshold )

    # determine if there is at least one legal move (ignoring dealing 10 cards from the stack!)    
    def legalmoveexists(self,threshold):
        for foo in range(10):
            for bar in range(10):
                if( self.islegal2(foo,bar,threshold)):
                    return True
        return False
                
    def makerandommove(self,threshold):    
        if( self.legalmoveexists(threshold)):
            while True:
                foo = np.random.randint(10)
                bar = np.random.randint(10)
                if( self.islegal2(foo,bar,threshold)):
                    self.makemove(foo,bar)
                    return
#        elif( threshold == 3): # if threshold = 3, then relax it to 2
#            if( self.legalmoveexists(threshold=2)):
#                while True:
#                    foo = np.random.randint(10)
#                    bar = np.random.randint(10)
#                    if( self.islegal2(foo,bar,threshold=2)):
#                        self.makemove(foo,bar)
#                        return
        return
               
    # execute move block. Moves are encoded as integers. Assume there are N legal moves then integer k
    # corresponds to the (k-modulo-N)th move
    def executemoveblock(self,moveblock,threshold,allowturnovers):
        movesplayed = []
        # if allowturnovers = True then stop making moves as soon as one card is turned over
        # if allowturnovers = False then don't expose a face-down card at the head of a column.                             
        # this avoids the AI cheating by knowing the identity of face-down cards when trying to find the best play.     
        for myint in moveblock:
            templist = []
            for i in range(10):
                for j in range(10):
                    if( self.islegal(i,j) >= threshold):
                        mytuple = (i,j)
                        templist.append( mytuple )
            if( len(templist) > 0):
                mytuple = templist[myint % len(templist)]
                self.makemove(mytuple[0], mytuple[1])
                movesplayed.append(mytuple)
            else:
                break
            if( allowturnovers):                
                if( self.turnovercards() == True):
                    return movesplayed
        self.turnovercards()
        return movesplayed
        
    # turn over face-down cards that are head of a column.
    # return true if at least one card turned over
    def turnovercards(self):
        flag = False 
        for i in range(10):
            col = self.columns[i]
            if( len(col) > 0):
                topcard = col[len(col)-1]
                if( topcard.isvisible == False):
                    flag = True
                topcard.setvisible(True)
        return flag
                      
    # evaluate how good a position is
    def evaluateposition(self):        
        myeval = 100 * self.countsuitsremoved() + self.countsuitedbuilds() + 10*(44 - self.counthiddencards())
        return myeval
            
    # assume move is legal
    def makemove(self,fromid,toid):    
        rl = self.runlength(fromid)
        
        # shorten the run length if breaking a sequence
        fromcol = self.columns[fromid]
        tocol = self.columns[toid]
        if( len(tocol) > 0):
            from_topcard = fromcol[len(fromcol) - 1]
            to_topcard = tocol[len(tocol) - 1]
            rl = to_topcard.getrank() - from_topcard.getrank()
        
        fromlength = len(self.columns[fromid])
        self.columns[toid] = self.columns[toid] + self.columns[fromid][fromlength-rl:fromlength]
        self.columns[fromid] = self.columns[fromid][0:fromlength - rl]
        self.clearsuits()
        # NOTE: turning over cards is the responsibility of some other function, not this one!
            
    # count the number of suited builds
    def countsuitedbuilds(self):
        total = 0
        for i in range(10):
            column = self.columns[i]
            for j in range(len(column) - 1):
                card1 = column[j]
                card2 = column[j+1]
                if( card1.issamesuit(card2) and card1.isprevrank(card2) and card1.isvisible and card2.isvisible):
                    total += 1
        return total

    # count the number of suits removed
    def countsuitsremoved(self):
        total = 0
        for i in range(10):
            total += len(self.columns[i]) + len(self.stock[i])
        return (104 - total) / 13

    # count the number of face-down cards
    def counthiddencards(self):
        total = 0
        for i in range(10):
            for c in self.columns[i]:
                if(c.isvisible == False):
                    total += 1
        return total

    # count the number of face-down cards in a single column
    def counthiddencards_column(self,mycolumn):
        total = 0
        for c in self.columns[mycolumn]:
            if( c.isvisible == False):
                total += 1
        return total

    # determine if the game is won
    def iswon(self):
        return ( self.countsuitsremoved() == 8 )
    
    # deal a row from stock
    def dealrow(self):
        for i in range(10):
            c = self.stock[i].pop(0)
            self.columns[i].append(c)
    
    # remove a complete run
    def clearsuits(self):
        for i in range(10):
            column = self.columns[i]
            rl = self.runlength(i)
            if( rl == 13):
                self.columns[i] = self.columns[i][0:len(column)-13]
                        
    # print the current game state
    def print_state(self, filename = None):
        if( filename == None):
            for linecounter in range(10):
                print("-> ", end='')
                for c in self.columns[linecounter]:
                    print(c.card2string() + ' ', end=''),
                print(),
            for linecounter in range(10):
                print("--> ", end='')
                for c in self.stock[linecounter]:
                    print(c.card2string() + ' ', end=''),
                print(),
        else:        
            with open(filename,mode='w') as f:
                for linecounter in range(10):
                    for c in self.columns[linecounter]:
                        f.write(c.card2string() + ' ')
                
                    f.write('\n')
                for linecounter in range(10):
                    
                    for c in self.stock[linecounter]:
                        f.write(c.card2string() + ' ')
                    f.write('\n')

    # print the current game state into a data format that can be read by canvas
    def printstate_canvas(self):
        data = []
        for i in range(10):
            for j in range(len(self.columns[i])):
                tempcard = self.columns[i][j]
                datum = [50 + 30*j, 100 + 15*i, tempcard.card2string(), tempcard.card2color()]
                data.append(datum)
        for i in range(10):
            for j in range(len(self.stock[i])):
                tempcard = self.stock[i][j]
                datum = [50 + 30*j, 300 + 15*i, tempcard.card2string(), tempcard.card2color()]
                data.append(datum)
                
                
        return data        
